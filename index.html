<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Blodlabyrinten – Myggskräcken</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,user-scalable=no" />
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #550000 0, #020005 60%);
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #game {
      position: relative;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #hud {
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 10px;
      background: rgba(0,0,0,0.6);
      border-radius: 999px;
      font-size: 12px;
      text-align: center;
      z-index: 10;
      max-width: 95%;
      pointer-events: none;
    }
    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 150px;
      height: 150px;
      z-index: 20;
    }
    .btnDir {
      position: absolute;
      width: 50px;
      height: 50px;
      background: rgba(0,0,0,0.6);
      border-radius: 999px;
      border: 1px solid rgba(255,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fdd;
      font-size: 20px;
      user-select: none;
    }
    .btnDir:active {
      background: rgba(200,0,0,0.9);
    }
    #btnUp   { left: 50px; top: 0; }
    #btnDown { left: 50px; top: 100px; }
    #btnLeft { left: 0; top: 50px; }
    #btnRight{ left: 100px; top: 50px; }

    #message {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 25px;
      background: rgba(0,0,0,0.9);
      border: 2px solid #900;
      border-radius: 10px;
      text-align: center;
      z-index: 30;
      max-width: 80%;
      display: none;
    }
    #message h1 {
      margin: 0 0 10px;
      font-size: 24px;
      color: #ff3333;
    }
    #message p {
      margin: 4px 0;
      font-size: 14px;
    }
    #message button {
      margin-top: 12px;
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #ff0000, #ff8800);
      color: #111;
      font-size: 14px;
      cursor: pointer;
    }

    body.cageFlash {
      animation: cageFlash 0.5s linear;
    }

    @keyframes cageFlash {
      0%   { filter: none; }
      25%  { filter: hue-rotate(90deg) brightness(1.5); }
      50%  { filter: invert(1) contrast(1.4); }
      100% { filter: none; }
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="canvas"></canvas>
    <div id="hud">Du och myggan spawnar i samma blodrum. Fly, ät smådjur, överlev.</div>

    <div id="controls">
      <div class="btnDir" id="btnUp">▲</div>
      <div class="btnDir" id="btnDown">▼</div>
      <div class="btnDir" id="btnLeft">◀</div>
      <div class="btnDir" id="btnRight">▶</div>
    </div>

    <div id="message">
      <h1>FÅNGAD!</h1>
      <p id="msgTime"></p>
      <p id="msgBest"></p>
      <p>Du vaknar upp i en blodig bur.</p>
      <p>Ät fler smådjur nästa gång för att bli immun.</p>
      <button id="btnRestart">Spela igen</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");
    const msgBox = document.getElementById("message");
    const msgTime = document.getElementById("msgTime");
    const msgBest = document.getElementById("msgBest");
    const btnRestart = document.getElementById("btnRestart");

    let W = window.innerWidth;
    let H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;

    let audioCtx = null;
    let gameState = "playing"; // "playing" | "caught"

    const player = { x: 80, y: 80, r: 14, speed: 2.4 };
    const mosquito = { x: 300, y: 200, r: 12, speed: 2.1 };

    const walls = [];
    const bloodDrops = [];
    const animals = [];

    const dir = { up: false, down: false, left: false, right: false };

    let immuneUntil = 0;
    let startTime = performance.now();
    let bestTime = 0;
    let lastSurvival = 0;

    // startpositioner (sätts i buildMaze)
    let startPlayer = { x: 80, y: 80 };
    let startMosquito = { x: 300, y: 200 };

    function ensureAudio() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioCtx = new AC();
        }
      }
    }

    function playBuzz(distance) {
      ensureAudio();
      if (!audioCtx) return;
      const ctxA = audioCtx;
      const osc = ctxA.createOscillator();
      const gain = ctxA.createGain();

      const maxDist = 600;
      const intensity = Math.max(0.1, 1 - distance / maxDist);
      const baseFreq = 150 + 700 * intensity;
      const freq = isImmune() ? baseFreq * 0.5 : baseFreq;

      osc.type = "sawtooth";
      osc.frequency.value = freq;

      const now = ctxA.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.1 * intensity, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);

      osc.connect(gain);
      gain.connect(ctxA.destination);
      osc.start(now);
      osc.stop(now + 0.23);
    }

    function playScreech() {
      ensureAudio();
      if (!audioCtx) return;
      const ctxA = audioCtx;
      const osc = ctxA.createOscillator();
      const gain = ctxA.createGain();
      osc.type = "square";
      const now = ctxA.currentTime;
      osc.frequency.setValueAtTime(1500, now);
      osc.frequency.exponentialRampToValueAtTime(200, now + 0.4);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      osc.connect(gain);
      gain.connect(ctxA.destination);
      osc.start(now);
      osc.stop(now + 0.45);
    }

    function playCageHit() {
      ensureAudio();
      if (!audioCtx) return;
      const ctxA = audioCtx;
      const osc = ctxA.createOscillator();
      const gain = ctxA.createGain();
      osc.type = "triangle";
      const now = ctxA.currentTime;
      osc.frequency.setValueAtTime(80, now);
      osc.frequency.exponentialRampToValueAtTime(40, now + 0.25);
      gain.gain.setValueAtTime(0.3, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      osc.connect(gain);
      gain.connect(ctxA.destination);
      osc.start(now);
      osc.stop(now + 0.28);
    }

    function playPowerup() {
      ensureAudio();
      if (!audioCtx) return;
      const ctxA = audioCtx;
      const osc = ctxA.createOscillator();
      const gain = ctxA.createGain();
      osc.type = "sine";
      const now = ctxA.currentTime;
      osc.frequency.setValueAtTime(300, now);
      osc.frequency.exponentialRampToValueAtTime(900, now + 0.25);
      gain.gain.setValueAtTime(0.25, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      osc.connect(gain);
      gain.connect(ctxA.destination);
      osc.start(now);
      osc.stop(now + 0.27);
    }

    function isImmune() {
      return performance.now() < immuneUntil;
    }

    function addBlood(x, y, big = false) {
      const amount = big ? 8 : 3;
      for (let i = 0; i < amount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = (big ? 40 : 18) * Math.random();
        const bx = x + Math.cos(angle) * dist;
        const by = y + Math.sin(angle) * dist;
        bloodDrops.push({
          x: bx,
          y: by,
          r: big ? 5 + Math.random() * 6 : 2 + Math.random() * 3,
          alpha: big ? 0.9 : 0.7
        });
      }
    }

    function buildMaze() {
      walls.length = 0;
      const thick = 20;

      // yttre väggar
      walls.push({ x: 0, y: 0, w: W, h: thick });
      walls.push({ x: 0, y: H - thick, w: W, h: thick });
      walls.push({ x: 0, y: 0, w: thick, h: H });
      walls.push({ x: W - thick, y: 0, w: thick, h: H });

      // CENTRALT "RUM" där båda spawnar
      const roomW = W * 0.45;
      const roomH = H * 0.45;
      const roomX = (W - roomW) / 2;
      const roomY = (H - roomH) / 2;
      const doorW = Math.max(70, roomW * 0.25); // öppning i taket

      // toppvägg med dörr i mitten
      const topLeftW = (roomW - doorW) / 2;
      const topRightX = roomX + topLeftW + doorW;
      walls.push({ x: roomX,         y: roomY, w: topLeftW,   h: thick });
      walls.push({ x: topRightX,     y: roomY, w: topLeftW,   h: thick });

      // bottenvägg (helt stängd)
      walls.push({ x: roomX,         y: roomY + roomH, w: roomW, h: thick });

      // sidoväggar (lite lägre för öppning nedåt)
      const sideGapH = 60;
      // vänster
      walls.push({ x: roomX, y: roomY, w: thick, h: (roomH - sideGapH) / 2 });
      walls.push({ x: roomX, y: roomY + (roomH + sideGapH) / 2, w: thick, h: (roomH - sideGapH) / 2 });
      // höger
      walls.push({ x: roomX + roomW, y: roomY, w: thick, h: (roomH - sideGapH) / 2 });
      walls.push({ x: roomX + roomW, y: roomY + (roomH + sideGapH) / 2, w: thick, h: (roomH - sideGapH) / 2 });

      // NÅGRA FÅ EXTRA VÄGGAR ute i labyrinten (mycket öppet)
      const midY = H * 0.6;
      walls.push({ x: W * 0.15, y: midY, w: W * 0.25, h: thick });
      walls.push({ x: W * 0.6,  y: midY, w: W * 0.25, h: thick });

      const midX = W * 0.3;
      walls.push({ x: midX, y: H * 0.15, w: thick, h: H * 0.25 });
      walls.push({ x: W * 0.6, y: H * 0.65, w: thick, h: H * 0.2 });

      // sätt startpositioner i rummet
      startPlayer.x = roomX + roomW * 0.3;
      startPlayer.y = roomY + roomH * 0.7;
      startMosquito.x = roomX + roomW * 0.7;
      startMosquito.y = roomY + roomH * 0.3;

      // lite initiala blodhögar
      bloodDrops.length = 0;
      for (let i = 0; i < 10; i++) {
        addBlood(
          roomX + 20 + Math.random() * (roomW - 40),
          roomY + 20 + Math.random() * (roomH - 40),
          true
        );
      }
    }

    function circleRectCollision(cx, cy, cr, rect) {
      const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
      const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx * dx + dy * dy) < cr * cr;
    }

    function canMoveTo(x, y, r) {
      for (const w of walls) {
        if (circleRectCollision(x, y, r, w)) return false;
      }
      return true;
    }

    function updatePlayer() {
      let vx = 0, vy = 0;
      if (dir.up) vy -= 1;
      if (dir.down) vy += 1;
      if (dir.left) vx -= 1;
      if (dir.right) vx += 1;
      if (vx === 0 && vy === 0) return;

      const len = Math.sqrt(vx * vx + vy * vy) || 1;
      vx = (vx / len) * player.speed;
      vy = (vy / len) * player.speed;

      const nx = player.x + vx;
      const ny = player.y + vy;

      if (canMoveTo(nx, player.y, player.r)) player.x = nx;
      if (canMoveTo(player.x, ny, player.r)) player.y = ny;

      addBlood(player.x, player.y, false);
    }

    function updateMosquito() {
      const dx = player.x - mosquito.x;
      const dy = player.y - mosquito.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      let step = mosquito.speed;

      let vx, vy;
      if (isImmune()) {
        // flyr från spelaren när du är immun
        vx = (-dx / dist) * step * 1.2;
        vy = (-dy / dist) * step * 1.2;
      } else {
        vx = (dx / dist) * step;
        vy = (dy / dist) * step;
      }

      const nx = mosquito.x + vx;
      const ny = mosquito.y + vy;

      if (canMoveTo(nx, mosquito.y, mosquito.r)) mosquito.x = nx;
      if (canMoveTo(mosquito.x, ny, mosquito.r)) mosquito.y = ny;

      if (!isImmune() && dist < player.r + mosquito.r + 4) {
        catchPlayer();
      }
    }

    function spawnAnimal() {
      const padding = 60;
      let x, y, tries = 0;
      do {
        x = padding + Math.random() * (W - padding * 2);
        y = padding + Math.random() * (H - padding * 2);
        tries++;
      } while (!canMoveTo(x, y, 10) && tries < 20);

      const speciesList = ["råtta", "groda", "kråka", "fladdermus"];
      const species = speciesList[Math.floor(Math.random() * speciesList.length)];

      animals.push({
        x, y,
        r: 10,
        species,
        active: true
      });
    }

    function spawnAnimalsInitial() {
      animals.length = 0;
      const n = 6;
      for (let i = 0; i < n; i++) spawnAnimal();
    }

    function eatAnimal(a) {
      if (!a.active) return;
      a.active = false;
      immuneUntil = performance.now() + 6000; // 6 sek immun
      addBlood(a.x, a.y, true);
      playPowerup();
    }

    function updateAnimals() {
      for (const a of animals) {
        if (!a.active) continue;
        const dx = player.x - a.x;
        const dy = player.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        if (dist < player.r + a.r + 3) {
          eatAnimal(a);
        }
      }
      // se till att det alltid finns några aktiva smådjur
      const activeCount = animals.filter(a => a.active).length;
      if (activeCount < 3 && Math.random() < 0.02) {
        spawnAnimal();
      }
    }

    function catchPlayer() {
      if (gameState === "caught" || isImmune()) return;
      gameState = "caught";
      addBlood(player.x, player.y, true);
      playBuzz(0);
      playScreech();
      playCageHit();
      document.body.classList.add("cageFlash");
      setTimeout(() => document.body.classList.remove("cageFlash"), 500);

      const now = performance.now();
      lastSurvival = (now - startTime) / 1000;
      if (lastSurvival > bestTime) bestTime = lastSurvival;

      msgTime.textContent = "Du överlevde: " + lastSurvival.toFixed(1).replace(".", ",") + " sekunder.";
      msgBest.textContent = "Bästa tid: " + bestTime.toFixed(1).replace(".", ",") + " sekunder.";
      msgBox.style.display = "block";
    }

    function drawBackground() {
      const grad = ctx.createRadialGradient(
        W * 0.5, H * 0.3, 50,
        W * 0.5, H * 0.5, Math.max(W, H)
      );
      grad.addColorStop(0, "#330000");
      grad.addColorStop(0.4, "#220000");
      grad.addColorStop(1, "#020003");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
    }

    function drawBlood() {
      for (let i = 0; i < bloodDrops.length; i++) {
        const b = bloodDrops[i];
        ctx.beginPath();
        ctx.fillStyle = `rgba(180,0,0,${b.alpha})`;
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawWalls() {
      ctx.fillStyle = "#190000";
      ctx.strokeStyle = "#550000";
      ctx.lineWidth = 2;
      for (const w of walls) {
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeRect(w.x, w.y, w.w, w.h);
      }
    }

    function drawAnimals() {
      for (const a of animals) {
        if (!a.active) continue;
        ctx.save();
        ctx.translate(a.x, a.y);

        // blodig aura
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255,0,0,0.6)";
        ctx.lineWidth = 2;
        ctx.arc(0, 0, a.r + 4, 0, Math.PI * 2);
        ctx.stroke();

        // kropp – lite olika beroende på art
        if (a.species === "råtta") {
          ctx.fillStyle = "#444";
          ctx.beginPath();
          ctx.ellipse(0, 0, a.r + 2, a.r, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#000";
          ctx.beginPath();
          ctx.arc(4, -3, 1.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#900";
          ctx.beginPath();
          ctx.moveTo(-a.r, 2);
          ctx.lineTo(-a.r - 6, 4);
          ctx.stroke();
        } else if (a.species === "groda") {
          ctx.fillStyle = "#225500";
          ctx.beginPath();
          ctx.ellipse(0, 0, a.r, a.r * 0.8, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#bbffbb";
          ctx.beginPath();
          ctx.arc(-4, -4, 2, 0, Math.PI * 2);
          ctx.arc(4, -4, 2, 0, Math.PI * 2);
          ctx.fill();
        } else if (a.species === "kråka") {
          ctx.fillStyle = "#111111";
          ctx.beginPath();
          ctx.ellipse(0, 0, a.r + 3, a.r - 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#ffcc00";
          ctx.beginPath();
          ctx.moveTo(2, -2);
          ctx.lineTo(8, 0);
          ctx.lineTo(2, 2);
          ctx.closePath();
          ctx.fill();
        } else {
          // fladdermus
          ctx.fillStyle = "#222222";
          ctx.beginPath();
          ctx.ellipse(0, 0, a.r, a.r - 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(-a.r, 0);
          ctx.quadraticCurveTo(-a.r * 0.5, -8, 0, 0);
          ctx.quadraticCurveTo(a.r * 0.5, -8, a.r, 0);
          ctx.lineTo(0, 0);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();
      }
    }

    function drawPlayer() {
      const immune = isImmune();
      ctx.save();
      ctx.translate(player.x, player.y);

      // blodring / immunitet
      ctx.beginPath();
      ctx.strokeStyle = immune ? "rgba(0,255,150,0.9)" : "rgba(255,0,0,0.6)";
      ctx.lineWidth = immune ? 4 : 3;
      ctx.arc(0, 0, player.r + 4, 0, Math.PI * 2);
      ctx.stroke();

      // huvud
      ctx.beginPath();
      ctx.fillStyle = immune ? "#e0ffe0" : "#f2dede";
      ctx.arc(0, -player.r * 0.7, player.r * 0.6, 0, Math.PI * 2);
      ctx.fill();

      // ögon
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(-4, -player.r * 0.8, 2, 0, Math.PI * 2);
      ctx.arc(4, -player.r * 0.8, 2, 0, Math.PI * 2);
      ctx.fill();

      // mun
      ctx.beginPath();
      ctx.strokeStyle = immune ? "#0a0" : "#900";
      ctx.lineWidth = 1.5;
      ctx.arc(0, -player.r * 0.4, 4, 0, Math.PI);
      ctx.stroke();

      // kropp
      ctx.strokeStyle = immune ? "#c0ffc0" : "#f2dede";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, -player.r * 0.1);
      ctx.lineTo(0, player.r * 0.9);
      ctx.stroke();

      // armar
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-player.r, player.r * 0.3);
      ctx.moveTo(0, 0);
      ctx.lineTo(player.r, player.r * 0.3);
      ctx.stroke();

      // ben
      ctx.beginPath();
      ctx.moveTo(0, player.r * 0.9);
      ctx.lineTo(-player.r * 0.7, player.r * 1.7);
      ctx.moveTo(0, player.r * 0.9);
      ctx.lineTo(player.r * 0.7, player.r * 1.7);
      ctx.stroke();

      ctx.restore();
    }

    function drawMosquito() {
      ctx.save();
      ctx.translate(mosquito.x, mosquito.y);

      const t = Date.now() * 0.01;
      const wingAngle = Math.sin(t * 0.7) * 0.5;

      // blodgloria
      ctx.beginPath();
      ctx.strokeStyle = isImmune() ? "rgba(150,0,0,0.7)" : "rgba(255,0,0,0.9)";
      ctx.lineWidth = 2;
      ctx.arc(0, 0, mosquito.r + 10, 0, Math.PI * 2);
      ctx.stroke();

      // vingar
      ctx.save();
      ctx.rotate(-0.4 + wingAngle);
      ctx.beginPath();
      ctx.fillStyle = "rgba(200,200,255,0.4)";
      ctx.ellipse(-4, -mosquito.r - 6, 5, 12, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.rotate(0.4 - wingAngle);
      ctx.beginPath();
      ctx.fillStyle = "rgba(200,200,255,0.4)";
      ctx.ellipse(4, -mosquito.r - 6, 5, 12, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // kropp
      ctx.beginPath();
      ctx.fillStyle = "#660000";
      ctx.ellipse(0, 0, mosquito.r + 2, mosquito.r - 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // "magen" full av blod
      ctx.beginPath();
      ctx.fillStyle = "#cc0000";
      ctx.ellipse(0, 4, mosquito.r, mosquito.r - 4, 0, 0, Math.PI * 2);
      ctx.fill();

      // ögon
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(-4, -4, 3, 0, Math.PI * 2);
      ctx.arc(4, -4, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.arc(-4, -4, 1.5, 0, Math.PI * 2);
      ctx.arc(4, -4, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // snabel
      ctx.beginPath();
      ctx.strokeStyle = "#bb0000";
      ctx.lineWidth = 2;
      ctx.moveTo(0, -1);
      ctx.lineTo(0, -mosquito.r - 6);
      ctx.stroke();

      ctx.restore();
    }

    function drawCageOverlay() {
      if (gameState !== "caught") return;
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, W, H);

      ctx.strokeStyle = "rgba(180,180,180,0.7)";
      ctx.lineWidth = 4;

      const bars = 10;
      for (let i = 0; i <= bars; i++) {
        const x = (W / bars) * i;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }

      for (let j = 0; j < 4; j++) {
        const y = (H / 4) * j;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      ctx.restore();
    }

    function draw() {
      drawBackground();
      drawBlood();
      drawWalls();
      drawAnimals();
      drawPlayer();
      drawMosquito();
      drawCageOverlay();
    }

    function updateHudText() {
      const now = performance.now();
      const t = (gameState === "playing") ? (now - startTime) / 1000 : lastSurvival;
      const tStr = t.toFixed(1).replace(".", ",");
      const bestStr = bestTime.toFixed(1).replace(".", ",");

      let extra;
      if (gameState === "playing") {
        extra = isImmune()
          ? " – IMMUN! Myggan flyr, passa på."
          : " – Ät smådjur för några sekunders immunitet.";
      } else {
        extra = " – Fångad. Tryck Spela igen.";
      }

      hud.textContent = `Tid: ${tStr} s | Rekord: ${bestStr} s${extra}`;
    }

    function update() {
      if (gameState === "playing") {
        updatePlayer();
        updateMosquito();
        updateAnimals();
      }
    }

    function loop() {
      update();
      draw();
      updateHudText();
      requestAnimationFrame(loop);
    }

    // buzz-ljud med intervall
    setInterval(() => {
      if (gameState !== "playing") return;
      const dx = player.x - mosquito.x;
      const dy = player.y - mosquito.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      playBuzz(dist);
      if (!isImmune() && Math.random() < 0.1 && dist < 350) playScreech();
    }, 350);

    // input – tangentbord
    window.addEventListener("keydown", (e) => {
      ensureAudio();
      if (e.key === "ArrowUp" || e.key === "w") dir.up = true;
      if (e.key === "ArrowDown" || e.key === "s") dir.down = true;
      if (e.key === "ArrowLeft" || e.key === "a") dir.left = true;
      if (e.key === "ArrowRight" || e.key === "d") dir.right = true;
      if (e.key === "r" && gameState === "caught") restart();
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "ArrowUp" || e.key === "w") dir.up = false;
      if (e.key === "ArrowDown" || e.key === "s") dir.down = false;
      if (e.key === "ArrowLeft" || e.key === "a") dir.left = false;
      if (e.key === "ArrowRight" || e.key === "d") dir.right = false;
    });

    // touch / mobilkontroller
    function setupTouchButton(id, prop) {
      const el = document.getElementById(id);
      const start = (ev) => {
        ev.preventDefault();
        ensureAudio();
        dir[prop] = true;
      };
      const end = (ev) => {
        ev.preventDefault();
        dir[prop] = false;
      };
      el.addEventListener("touchstart", start);
      el.addEventListener("touchend", end);
      el.addEventListener("touchcancel", end);
      el.addEventListener("mousedown", start);
      window.addEventListener("mouseup", end);
    }

    setupTouchButton("btnUp", "up");
    setupTouchButton("btnDown", "down");
    setupTouchButton("btnLeft", "left");
    setupTouchButton("btnRight", "right");

    function restart() {
      gameState = "playing";
      msgBox.style.display = "none";
      player.x = startPlayer.x;
      player.y = startPlayer.y;
      mosquito.x = startMosquito.x;
      mosquito.y = startMosquito.y;
      immuneUntil = 0;
      startTime = performance.now();
      spawnAnimalsInitial();
    }

    btnRestart.addEventListener("click", () => {
      ensureAudio();
      restart();
    });

    window.addEventListener("resize", () => {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W;
      canvas.height = H;
      buildMaze();
      restart();
    });

    buildMaze();
    restart();
    loop();
  </script>
</body>
</html>